// Generated by CoffeeScript 1.8.0
var AsarArchive, UINT64, crawlFilesystem, fs, mkdirp, path, pickle, walkdir;

fs = require('fs');

path = require('path');

walkdir = require('walkdir');

mkdirp = require('mkdirp');

pickle = require('chromium-pickle');

UINT64 = require('cuint').UINT64;

crawlFilesystem = function(dir, cb) {
  var emitter, metadata, paths;
  paths = [];
  metadata = {};
  emitter = walkdir(dir);
  emitter.on('directory', function(p, stat) {
    paths.push(p);
    metadata[p] = {
      type: 'directory',
      stat: stat
    };
  });
  emitter.on('file', function(p, stat) {
    paths.push(p);
    metadata[p] = {
      type: 'file',
      stat: stat
    };
  });
  emitter.on('link', function(p, stat) {
    paths.push(p);
    metadata[p] = {
      type: 'link',
      stat: stat
    };
  });
  emitter.on('end', function() {
    paths.sort();
    return cb(null, paths, metadata);
  });
  emitter.on('error', cb);
};

module.exports = AsarArchive = (function() {
  function AsarArchive() {
    this.reset();
    return;
  }

  AsarArchive.prototype.MAGIC = 'ASAR';

  AsarArchive.prototype.VERSION = 1;

  AsarArchive.prototype.reset = function() {
    this._header = {
      version: this.VERSION,
      files: {}
    };
    this._headerSize = 0;
    this._offset = UINT64(0);
    this._files = [];
    this._archiveName = null;
  };

  AsarArchive.prototype._searchNode = function(p, create) {
    var dir, dirs, name, node, _i, _len;
    if (create == null) {
      create = true;
    }
    if (p[0] === path.sep) {
      p = p.substr(1);
    }
    name = path.basename(p);
    node = this._header;
    dirs = path.dirname(p).split(path.sep);
    for (_i = 0, _len = dirs.length; _i < _len; _i++) {
      dir = dirs[_i];
      if (node == null) {
        throw new Error("" + p + " not found.");
      }
      if (dir !== '.') {
        node = node.files[dir];
      }
    }
    if (create) {
      node.files[name] = {};
    }
    if (node == null) {
      throw new Error("" + p + " not found.");
    }
    node = node.files[name];
    return node;
  };

  AsarArchive.prototype._readHeader = function(fd) {
    var headerBuf, headerStr, magicBuf, magicLen, size, sizeBuf, sizeBufSize;
    magicLen = this.MAGIC.length;
    magicBuf = new Buffer(magicLen);
    if (fs.readSync(fd, magicBuf, 0, magicLen, null) !== magicLen) {
      throw new Error('Unable to read from archive');
    }
    if (magicBuf.toString() !== this.MAGIC) {
      console.error('Deprecation notice: old version of asar archive.');
      return this._readHeaderOld(fd);
    }
    sizeBufSize = 4;
    sizeBuf = new Buffer(sizeBufSize);
    if (fs.readSync(fd, sizeBuf, 0, sizeBufSize, null) !== sizeBufSize) {
      throw new Error('Unable to read header size');
    }
    size = sizeBuf.readUInt32BE(0);
    headerBuf = new Buffer(size);
    if (fs.readSync(fd, headerBuf, 0, size, null) !== size) {
      throw new Error('Unable to read header');
    }
    headerStr = headerBuf.toString();
    return [headerBuf, size];
  };

  AsarArchive.prototype._readHeaderOld = function(fd) {
    var headerBuf, headerPickle, headerStr, size, sizeBuf, sizeBufSize, sizePickle;
    sizeBufSize = 8;
    sizeBuf = new Buffer(sizeBufSize);
    if (fs.readSync(fd, sizeBuf, 0, sizeBufSize, 0) !== sizeBufSize) {
      throw new Error('Unable to read header size');
    }
    sizePickle = pickle.createFromBuffer(sizeBuf);
    size = sizePickle.createIterator().readUInt32();
    headerBuf = new Buffer(size);
    if (fs.readSync(fd, headerBuf, 0, size, null) !== size) {
      throw new Error('Unable to read header');
    }
    headerPickle = pickle.createFromBuffer(headerBuf);
    headerStr = headerPickle.createIterator().readString();
    return [headerStr, size];
  };

  AsarArchive.prototype._writeHeader = function(out, cb) {
    var headerStr, sizeBuf;
    headerStr = JSON.stringify(this._header);
    sizeBuf = new Buffer(4);
    sizeBuf.writeUInt32BE(headerStr.length, 0);
    out.write(this.MAGIC, function() {
      return out.write(sizeBuf, function() {
        return out.write(headerStr, cb);
      });
    });
  };

  AsarArchive.prototype.openSync = function(archiveName) {
    var fd, headerStr, size, _ref;
    this.reset();
    this._archiveName = archiveName;
    fd = fs.openSync(archiveName, 'r');
    _ref = this._readHeader(fd), headerStr = _ref[0], size = _ref[1];
    fs.closeSync(fd);
    this._header = JSON.parse(headerStr);
    this._headerSize = size;
    if ((this._header.version != null) && this._header.version > this.VERSION) {
      throw new Error("Unsupported asar format version: " + this._header.version + " (max supported: " + this.VERSION + ")");
    }
    return true;
  };

  AsarArchive.prototype.write = function(archiveName, opts, cb) {
    var out, queue, writeFile;
    this._archiveName = archiveName;
    mkdirp.sync(path.dirname(archiveName));
    queue = require('queue-async');
    writeFile = function(filename, out, cb) {
      var src;
      src = fs.createReadStream(filename);
      src.on('end', cb);
      src.pipe(out, {
        end: false
      });
    };
    out = fs.createWriteStream(archiveName);
    this._writeHeader(out, (function(_this) {
      return function() {
        var file, q, _i, _len, _ref;
        q = queue(1);
        _ref = _this._files;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          file = _ref[_i];
          q.defer(writeFile, file, out);
          q.awaitAll(function(err) {
            return cb(err);
          });
        }
      };
    })(this));
  };

  AsarArchive.prototype.getEntries = function(archiveRoot) {
    var files, fillFilesFromHeader, json;
    if (archiveRoot == null) {
      archiveRoot = '/';
    }
    files = [];
    fillFilesFromHeader = function(p, json) {
      var f, fullPath;
      if ((json != null ? json.files : void 0) == null) {
        return;
      }
      for (f in json.files) {
        fullPath = path.join(p, f);
        files.push(fullPath);
        fillFilesFromHeader(fullPath, json.files[f]);
      }
    };
    if (archiveRoot === '/') {
      json = this._header;
    } else {
      json = this._searchNode(archiveRoot, false);
      archiveRoot = "" + path.sep + archiveRoot;
    }
    fillFilesFromHeader(archiveRoot, json);
    return files;
  };

  AsarArchive.prototype.getMetadata = function(filename) {
    var node;
    node = this._searchNode(filename, false);
    return node;
  };

  AsarArchive.prototype.getFile = function(filename) {
    var buffer, fd, node;
    fd = fs.openSync(this._archiveName, 'r');
    node = this._searchNode(filename, false);
    buffer = new Buffer(node.size);
    fs.readSync(fd, buffer, 0, node.size, 8 + this._headerSize + parseInt(node.offset, 10));
    fs.closeSync(fd);
    return buffer;
  };

  AsarArchive.prototype.extractFileSync = function(filename, destFilename) {
    mkdirp.sync(path.dirname(destFilename));
    fs.writeFileSync(destFilename, this.getFile(filename));
    return true;
  };

  AsarArchive.prototype.extractSync = function(destDir, archiveRoot) {
    var destFilename, filename, filenames, node, _i, _len;
    if (archiveRoot == null) {
      archiveRoot = '/';
    }
    mkdirp.sync(destDir);
    filenames = this.getEntries(archiveRoot);
    for (_i = 0, _len = filenames.length; _i < _len; _i++) {
      filename = filenames[_i];
      destFilename = path.join(destDir, filename);
      node = this._searchNode(filename, false);
      if (node.files) {
        mkdirp.sync(destFilename);
      } else {
        this.extractFileSync(filename, destFilename);
      }
    }
    return true;
  };

  AsarArchive.prototype.addFile = function(filename, relativeTo, stat, content) {
    var node, p;
    if (stat == null) {
      stat = null;
    }
    if (content == null) {
      content = null;
    }
    if (stat == null) {
      stat = fs.lstatSyc(filename);
    }
    if (stat.size > 4294967295) {
      throw new Error("" + p + ": file size can not be larger than 4.2GB");
    }
    this._files.push(filename);
    p = path.relative(relativeTo, filename);
    node = this._searchNode(p);
    node.size = stat.size;
    node.offset = this._offset.toString();
    if (process.platform === 'win32' && stat.mode & 0x40) {
      node.executable = true;
    }
    this._offset.add(UINT64(stat.size));
  };

  AsarArchive.prototype.createDirectory = function(dirname) {
    var entry;
    entry = this._searchNode(dirname);
    entry.files = {};
  };

  AsarArchive.prototype.addDirectory = function(dirname, relativeTo, cb) {
    crawlFilesystem(dirname, (function(_this) {
      return function(err, filenames, metadata) {
        var file, filename, _i, _len;
        for (_i = 0, _len = filenames.length; _i < _len; _i++) {
          filename = filenames[_i];
          file = metadata[filename];
          if (file.type === 'directory') {
            _this.createDirectory(path.relative(relativeTo, filename));
          } else if (file.type === 'file') {
            _this.addFile(filename, relativeTo, file.stat);
          }
        }
        return cb(null);
      };
    })(this));
  };

  return AsarArchive;

})();
