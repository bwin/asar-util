// Generated by CoffeeScript 1.8.0
var AsarArchive, crypto, fs, minimatch, mkdirp, os, path, queue, serialization, sortBy, stream, walkdir, zlib,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require('fs');

os = require('os');

path = require('path');

crypto = require('crypto');

stream = require('stream');

zlib = require('zlib');

walkdir = require('walkdir');

minimatch = require('minimatch');

mkdirp = require('mkdirp');

queue = require('queue-async');

serialization = require('./serialization');

sortBy = function(prop) {
  return function(a, b) {
    if (a[prop] < b[prop]) {
      return -1;
    }
    if (a[prop] > b[prop]) {
      return 1;
    }
    return 0;
  };
};

module.exports = AsarArchive = (function() {
  AsarArchive.prototype.MAGIC = 'ASAR\r\n';

  AsarArchive.prototype.VERSION = 1;

  AsarArchive.prototype.SIZELENGTH = 64 / 8;

  function AsarArchive(opts) {
    var _base;
    this.opts = opts != null ? opts : {};
    if ((_base = this.opts).minSizeToCompress == null) {
      _base.minSizeToCompress = 256;
    }
    this.reset();
    return;
  }

  AsarArchive.prototype.reset = function() {
    this._header = {
      version: this.VERSION,
      files: {}
    };
    this._headerSize = 0;
    this._offset = this.MAGIC.length;
    this._archiveSize = 0;
    this._files = [];
    this._fileNodes = [];
    this._archiveName = null;
    this._dirty = false;
    this._checksum = null;
    this._legacyMode = false;
  };

  AsarArchive.prototype._searchNode = function(p, create) {
    var dir, dirs, name, node, _base, _base1, _i, _len, _ref;
    if (create == null) {
      create = true;
    }
    if (_ref = p[0], __indexOf.call('/\\'.split(''), _ref) >= 0) {
      p = p.substr(1);
    }
    name = path.basename(p);
    node = this._header;
    dirs = path.dirname(p).split(path.sep);
    for (_i = 0, _len = dirs.length; _i < _len; _i++) {
      dir = dirs[_i];
      if (node == null) {
        throw new Error("" + p + " not found.");
      }
      if (dir !== '.') {
        if (create) {
          if ((_base = node.files)[dir] == null) {
            _base[dir] = {
              files: {}
            };
          }
        }
        node = node.files[dir];
      }
    }
    if (node == null) {
      throw new Error("" + p + " not found.");
    }
    if (create) {
      if ((_base1 = node.files)[name] == null) {
        _base1[name] = {};
      }
    }
    node = node.files[name];
    return node;
  };

  AsarArchive.prototype._crawlFilesystem = function(dir, pattern, cb) {
    var paths, walker;
    paths = [];
    walker = walkdir(dir);
    walker.on('path', function(p, stat) {
      paths.push({
        name: p,
        stat: stat
      });
    });
    walker.on('end', (function(_this) {
      return function() {
        var matchFn;
        if (pattern) {
          matchFn = minimatch.filter(pattern, {
            matchBase: true
          });
          paths = paths.filter(function(a) {
            return matchFn(path.sep + path.relative(dir, a.name));
          });
        }
        paths.sort(sortBy('name'));
        return typeof cb === "function" ? cb(null, paths) : void 0;
      };
    })(this));
    walker.on('error', cb);
  };

  AsarArchive.prototype.write = function(archiveName, opts, cb) {
    serialization.saveArchive(this, archiveName, opts, cb);
  };

  AsarArchive.prototype.verify = function(cb) {
    var archiveFile, endOfs, md5;
    endOfs = this._offset + this._headerSize + this.SIZELENGTH - 1;
    archiveFile = fs.createReadStream(this._archiveName, {
      start: 0,
      end: endOfs
    });
    md5 = crypto.createHash('md5');
    archiveFile.pipe(md5);
    archiveFile.on('end', (function(_this) {
      return function() {
        var actual, excpected;
        actual = md5.read().toString('hex');
        excpected = _this._checksum.toString('hex');
        cb(null, actual === excpected, {
          actual: actual,
          excpected: excpected
        });
      };
    })(this));
  };

  AsarArchive.prototype.getEntries = function(archiveRoot, pattern) {
    var files, fillFilesFromHeader, json, _ref;
    if (archiveRoot == null) {
      archiveRoot = '/';
    }
    if (pattern == null) {
      pattern = null;
    }
    if (archiveRoot.length > 1 && (_ref = archiveRoot[0], __indexOf.call('/\\'.split(''), _ref) >= 0)) {
      archiveRoot = archiveRoot.substr(1);
    }
    files = [];
    fillFilesFromHeader = function(p, json) {
      var f, fullPath;
      if ((json != null ? json.files : void 0) == null) {
        return;
      }
      for (f in json.files) {
        fullPath = path.join(p, f);
        files.push(fullPath);
        fillFilesFromHeader(fullPath, json.files[f]);
      }
    };
    if (archiveRoot === '/') {
      json = this._header;
    } else {
      json = this._searchNode(archiveRoot, false);
      if (json == null) {
        throw new Error("" + archiveRoot + " not found in " + this._archiveName);
      }
      if (json.size) {
        files.push(archiveRoot);
      }
      archiveRoot = "" + path.sep + archiveRoot;
    }
    fillFilesFromHeader(archiveRoot, json);
    if (pattern) {
      files = files.filter(minimatch.filter(pattern, {
        matchBase: true
      }));
    }
    return files;
  };

  AsarArchive.prototype.getMetadata = function(filename) {
    var node;
    node = this._searchNode(filename, false);
    return node;
  };

  AsarArchive.prototype.createReadStream = function(filename) {
    var emptyStream, end, gunzip, inStream, node, size, start;
    node = this._searchNode(filename, false);
    if (node.size > 0) {
      if (!this._legacyMode) {
        start = node.offset;
      } else {
        start = 8 + this._headerSize + parseInt(node.offset, 10);
      }
      size = node.csize || node.size;
      end = start + size - 1;
      inStream = fs.createReadStream(this._archiveName, {
        start: start,
        end: end
      });
      if (node.csize != null) {
        gunzip = zlib.createGunzip();
        inStream.pipe(gunzip);
        return gunzip;
      }
      return inStream;
    } else {
      emptyStream = stream.Readable();
      emptyStream.push(null);
      return emptyStream;
    }
  };

  AsarArchive.prototype.extract = function(dest, opts, cb) {
    var archiveRoot, destDir, destFilename, filename, filenames, linkTo, linkToRel, node, pattern, q, relativeTo, symlinksSupported, writeStreamToFile, _i, _len, _ref, _ref1;
    if (typeof opts === 'function') {
      cb = opts;
      opts = {};
    }
    if (typeof opts === 'string') {
      opts = {
        root: opts
      };
    }
    archiveRoot = opts.root || '/';
    pattern = opts.pattern;
    symlinksSupported = os.platform() !== 'win32';
    filenames = this.getEntries(archiveRoot, pattern);
    if (filenames.length === 1) {
      archiveRoot = path.dirname(archiveRoot);
    } else {
      mkdirp.sync(dest);
    }
    relativeTo = archiveRoot;
    if (_ref = relativeTo[0], __indexOf.call('/\\'.split(''), _ref) >= 0) {
      relativeTo = relativeTo.substr(1);
    }
    if (_ref1 = relativeTo.slice(-1), __indexOf.call('/\\'.split(''), _ref1) >= 0) {
      relativeTo = relativeTo.slice(0, -1);
    }
    writeStreamToFile = (function(_this) {
      return function(filename, destFilename, cb) {
        var inStream, out;
        inStream = _this.createReadStream(filename);
        out = fs.createWriteStream(destFilename);
        out.on('finish', cb);
        out.on('error', cb);
        inStream.pipe(out);
      };
    })(this);
    q = queue(1);
    for (_i = 0, _len = filenames.length; _i < _len; _i++) {
      filename = filenames[_i];
      destFilename = filename;
      if (relativeTo !== '.') {
        destFilename = destFilename.replace(relativeTo, '');
      }
      destFilename = path.join(dest, destFilename);
      if (this.opts.verbose) {
        console.log("-> " + destFilename);
      }
      node = this._searchNode(filename, false);
      if (node.files) {
        q.defer(mkdirp, destFilename);
      } else if (node.link) {
        if (symlinksSupported) {
          destDir = path.dirname(destFilename);
          q.defer(mkdirp, destDir);
          linkTo = path.join(destDir, relativeTo, node.link);
          linkToRel = path.relative(path.dirname(destFilename), linkTo);
          try {
            fs.unlinkSync(destFilename);
          } catch (_error) {}
          fs.symlinkSync(linkToRel, destFilename);
        } else {
          if (this.opts.verbose) {
            console.log("Warning: extracting symlinks on windows not yet supported. Skipping " + destFilename);
          }
        }
      } else {
        destDir = path.dirname(destFilename);
        q.defer(mkdirp, destDir);
        q.defer(writeStreamToFile, filename, destFilename);
      }
    }
    q.awaitAll(cb);
  };

  AsarArchive.prototype.addFile = function(filename, opts) {
    var node, p, relativeTo, stat;
    if (opts == null) {
      opts = {};
    }
    stat = opts.stat || fs.lstatSyc(filename);
    relativeTo = opts.relativeTo || path.dirname(filename);
    this._dirty = true;
    if (stat.size > serialization.MAX_SAFE_INTEGER) {
      throw new Error("" + p + ": file size can not be larger than 9PB");
    }
    p = path.relative(relativeTo, filename);
    node = this._searchNode(p);
    node.size = stat.size;
    if (node.size === 0) {
      return;
    }
    this._files.push(filename);
    this._fileNodes.push(node);
    if (process.platform === 'win32' && stat.mode & 0x40) {
      node.executable = true;
    }
  };

  AsarArchive.prototype.addSymlink = function(filename, opts) {
    var linkAbsolute, linkTo, node, p, pAbsDir, pDir, relativeTo;
    if (opts == null) {
      opts = {};
    }
    relativeTo = opts.relativeTo || path.dirname(filename);
    this._dirty = true;
    p = path.relative(relativeTo, filename);
    pDir = path.dirname(path.join(relativeTo, p));
    pAbsDir = path.resolve(pDir);
    linkAbsolute = fs.realpathSync(filename);
    linkTo = path.relative(pAbsDir, linkAbsolute);
    node = this._searchNode(p);
    node.link = linkTo;
  };

  AsarArchive.prototype.createDirectory = function(dirname) {
    var entry;
    this._dirty = true;
    entry = this._searchNode(dirname);
    if (entry.files == null) {
      entry.files = {};
    }
  };

  AsarArchive.prototype.addDirectory = function(dirname, opts, cb) {
    var relativeTo;
    if (opts == null) {
      opts = {};
    }
    if (cb == null) {
      cb = null;
    }
    this._dirty = true;
    if (typeof opts === 'function') {
      cb = opts;
      opts = {};
    }
    relativeTo = opts.relativeTo || dirname;
    this._crawlFilesystem(dirname, opts != null ? opts.pattern : void 0, (function(_this) {
      return function(err, files) {
        var file, _i, _len;
        for (_i = 0, _len = files.length; _i < _len; _i++) {
          file = files[_i];
          if (_this.opts.verbose) {
            console.log("+ " + path.sep + (path.relative(relativeTo, file.name)));
          }
          if (file.stat.isDirectory()) {
            _this.createDirectory(path.relative(relativeTo, file.name));
          } else if (file.stat.isFile()) {
            _this.addFile(file.name, {
              relativeTo: relativeTo,
              stat: file.stat
            });
          } else if (file.stat.isSymbolicLink()) {
            _this.addSymlink(file.name, {
              relativeTo: relativeTo
            });
          }
        }
        return typeof cb === "function" ? cb(null) : void 0;
      };
    })(this));
  };

  return AsarArchive;

})();
