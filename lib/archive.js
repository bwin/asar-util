// Generated by CoffeeScript 1.8.0
var AsarArchive, AsarArchiveFs, fs, mkdirp, path, queue,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require('fs');

path = require('path');

mkdirp = require('mkdirp');

queue = require('queue-async');

AsarArchiveFs = require('./archive-fs');

module.exports = AsarArchive = (function(_super) {
  __extends(AsarArchive, _super);

  function AsarArchive() {
    return AsarArchive.__super__.constructor.apply(this, arguments);
  }

  AsarArchive.prototype.verify = function(cb) {
    this._calcArchiveChecksum((function(_this) {
      return function(err, checksum) {
        var expected;
        expected = _this._checksum.toString('hex');
        return cb(null, checksum === expected, {
          checksum: checksum,
          expected: expected
        });
      };
    })(this));
  };

  AsarArchive.prototype.extract = function(dest, opts, cb) {
    var archiveRoot, destDir, destFilename, filename, filenames, node, pattern, q, relativeTo, _i, _len, _ref, _ref1;
    if (typeof opts === 'function') {
      cb = opts;
      opts = {};
    }
    if (typeof opts === 'string') {
      opts = {
        root: opts
      };
    }
    archiveRoot = opts.root || '/';
    pattern = opts.pattern;
    filenames = this.getEntries(archiveRoot, pattern);
    if (filenames.length === 1) {
      archiveRoot = path.dirname(archiveRoot);
    }
    relativeTo = archiveRoot;
    if (_ref = relativeTo[0], __indexOf.call('/\\'.split(''), _ref) >= 0) {
      relativeTo = relativeTo.substr(1);
    }
    if (_ref1 = relativeTo.slice(-1), __indexOf.call('/\\'.split(''), _ref1) >= 0) {
      relativeTo = relativeTo.slice(0, -1);
    }
    q = queue(1);
    for (_i = 0, _len = filenames.length; _i < _len; _i++) {
      filename = filenames[_i];
      destFilename = filename;
      if (relativeTo !== '.') {
        destFilename = destFilename.replace(relativeTo, '');
      }
      destFilename = path.join(dest, destFilename);
      destDir = path.dirname(destFilename);
      node = this._searchNode(filename, false);
      if (node.files) {
        q.defer(mkdirp, destFilename);
      } else {
        q.defer(mkdirp, destDir);
        if (node.link) {
          q.defer(this.extractSymlink, filename, destFilename);
        } else {
          q.defer(this.extractFile, filename, destFilename);
        }
      }
    }
    q.awaitAll(cb);
  };

  AsarArchive.prototype.addDirectory = function(dirname, opts, cb) {
    var relativeTo;
    if (opts == null) {
      opts = {};
    }
    if (cb == null) {
      cb = null;
    }
    this._dirty = true;
    if (typeof opts === 'function') {
      cb = opts;
      opts = {};
    }
    relativeTo = opts.relativeTo || dirname;
    this._crawlFilesystem(dirname, opts != null ? opts.pattern : void 0, (function(_this) {
      return function(err, files) {
        var file, _i, _len;
        for (_i = 0, _len = files.length; _i < _len; _i++) {
          file = files[_i];
          if (file.stat.isDirectory()) {
            _this.createDirectory(path.relative(relativeTo, file.name));
          } else if (file.stat.isFile()) {
            _this.addFile(file.name, {
              relativeTo: relativeTo,
              stat: file.stat
            });
          } else if (file.stat.isSymbolicLink()) {
            _this.addSymlink(file.name, {
              relativeTo: relativeTo
            });
          }
        }
        return typeof cb === "function" ? cb(null) : void 0;
      };
    })(this));
  };

  return AsarArchive;

})(AsarArchiveFs);
