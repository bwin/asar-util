// Generated by CoffeeScript 1.8.0
var AsarArchive, MAX_SAFE_INTEGER, UINT64, crypto, fs, minimatch, mkdirp, os, path, queue, readUINT64, sortBy, stream, walkdir, writeUINT64, zlib,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require('fs');

os = require('os');

path = require('path');

crypto = require('crypto');

stream = require('stream');

zlib = require('zlib');

UINT64 = require('cuint').UINT64;

walkdir = require('walkdir');

minimatch = require('minimatch');

mkdirp = require('mkdirp');

queue = require('queue-async');

MAX_SAFE_INTEGER = 9007199254740992;

writeUINT64 = function(buf, val, ofs) {
  var uintval;
  if (ofs == null) {
    ofs = 0;
  }
  uintval = UINT64(val);
  buf.writeUInt16LE(uintval._a00, ofs + 0);
  buf.writeUInt16LE(uintval._a16, ofs + 2);
  buf.writeUInt16LE(uintval._a32, ofs + 4);
  buf.writeUInt16LE(uintval._a48, ofs + 6);
  return buf;
};

readUINT64 = function(buf, ofs) {
  var hi, lo, val;
  if (ofs == null) {
    ofs = 0;
  }
  lo = buf.readUInt32LE(ofs + 0);
  hi = buf.readUInt32LE(ofs + 4);
  val = UINT64(lo, hi).toNumber();
  return val;
};

sortBy = function(prop) {
  return function(a, b) {
    if (a[prop] < b[prop]) {
      return -1;
    }
    if (a[prop] > b[prop]) {
      return 1;
    }
    return 0;
  };
};

module.exports = AsarArchive = (function() {
  AsarArchive.prototype.MAGIC = 'ASAR\r\n';

  AsarArchive.prototype.VERSION = 1;

  AsarArchive.prototype.SIZELENGTH = 64 / 8;

  function AsarArchive(opts) {
    var _base;
    this.opts = opts != null ? opts : {};
    if ((_base = this.opts).minSizeToCompress == null) {
      _base.minSizeToCompress = 256;
    }
    this.reset();
    return;
  }

  AsarArchive.prototype.reset = function() {
    this._header = {
      version: this.VERSION,
      files: {}
    };
    this._headerSize = 0;
    this._offset = this.MAGIC.length;
    this._archiveSize = 0;
    this._files = [];
    this._fileNodes = [];
    this._archiveName = null;
    this._dirty = false;
    this._checksum = null;
    this._legacyMode = false;
  };

  AsarArchive.prototype._searchNode = function(p, create) {
    var dir, dirs, name, node, _base, _base1, _i, _len, _ref;
    if (create == null) {
      create = true;
    }
    if (_ref = p[0], __indexOf.call('/\\'.split(''), _ref) >= 0) {
      p = p.substr(1);
    }
    name = path.basename(p);
    node = this._header;
    dirs = path.dirname(p).split(path.sep);
    for (_i = 0, _len = dirs.length; _i < _len; _i++) {
      dir = dirs[_i];
      if (node == null) {
        throw new Error("" + p + " not found.");
      }
      if (dir !== '.') {
        if (create) {
          if ((_base = node.files)[dir] == null) {
            _base[dir] = {
              files: {}
            };
          }
        }
        node = node.files[dir];
      }
    }
    if (node == null) {
      throw new Error("" + p + " not found.");
    }
    if (create) {
      if ((_base1 = node.files)[name] == null) {
        _base1[name] = {};
      }
    }
    node = node.files[name];
    return node;
  };

  AsarArchive.prototype._readHeader = function(fd) {
    var checksumOfs, checksumSize, err, headerBuf, headerOfs, headerSize, headerSizeBuf, headerSizeOfs, magicBuf, magicLen;
    magicLen = this.MAGIC.length;
    magicBuf = new Buffer(magicLen);
    if (fs.readSync(fd, magicBuf, 0, magicLen, null) !== magicLen) {
      throw new Error("Unable to open archive: " + this._archiveName);
    }
    if (magicBuf.toString() !== this.MAGIC) {
      return this._readHeaderOld(fd);
    }
    headerSizeOfs = this._archiveSize - (this.SIZELENGTH + 16 + this.SIZELENGTH);
    headerSizeBuf = new Buffer(this.SIZELENGTH);
    if (fs.readSync(fd, headerSizeBuf, 0, this.SIZELENGTH, headerSizeOfs) !== this.SIZELENGTH) {
      throw new Error("Unable to read header size: " + this._archiveName);
    }
    headerSize = readUINT64(headerSizeBuf);
    headerOfs = this._archiveSize - headerSize - (this.SIZELENGTH + 16 + this.SIZELENGTH);
    headerBuf = new Buffer(headerSize);
    if (fs.readSync(fd, headerBuf, 0, headerSize, headerOfs) !== headerSize) {
      throw new Error("Unable to read header: " + this._archiveName);
    }
    this._offset = headerOfs;
    checksumSize = 16;
    checksumOfs = this._archiveSize - 16 - this.SIZELENGTH;
    this._checksum = new Buffer(checksumSize);
    if (fs.readSync(fd, this._checksum, 0, checksumSize, checksumOfs) !== checksumSize) {
      throw new Error("Unable to read checksum: " + this._archiveName);
    }
    try {
      this._header = JSON.parse(headerBuf);
    } catch (_error) {
      err = _error;
      throw new Error("Unable to parse header: " + this._archiveName);
    }
    this._headerSize = headerSize;
  };

  AsarArchive.prototype._readHeaderOld = function(fd) {
    var actualSize, err, headerBuf, headerStr, size, sizeBuf, sizeBufSize;
    this._legacyMode = true;
    sizeBufSize = 8;
    sizeBuf = new Buffer(sizeBufSize);
    if (fs.readSync(fd, sizeBuf, 0, sizeBufSize, 0) !== sizeBufSize) {
      throw new Error('Unable to read header size (assumed old format)');
    }
    size = sizeBuf.readUInt32LE(4);
    actualSize = size - 8;
    headerBuf = new Buffer(actualSize);
    if (fs.readSync(fd, headerBuf, 0, actualSize, 16) !== actualSize) {
      throw new Error('Unable to read header (assumed old format)');
    }
    try {
      headerStr = headerBuf.toString().replace(/\0+$/g, '');
      this._header = JSON.parse(headerStr);
    } catch (_error) {
      err = _error;
      throw new Error('Unable to parse header (assumed old format)');
    }
    this._headerSize = size;
  };

  AsarArchive.prototype._writeHeader = function(out, cb) {
    out.write(this.MAGIC, cb);
  };

  AsarArchive.prototype._writeFooter = function(out, cb) {
    var headerSizeBuf, headerStr;
    if (this.opts.prettyToc) {
      headerStr = JSON.stringify(this._header, null, '  ').replace(/\n/g, '\r\n');
      headerStr = "\r\n" + headerStr + "\r\n";
    } else {
      headerStr = JSON.stringify(this._header);
    }
    this._headerSize = headerStr.length;
    headerSizeBuf = new Buffer(this.SIZELENGTH);
    writeUINT64(headerSizeBuf, this._headerSize);
    out.write(headerStr, (function(_this) {
      return function() {
        out.write(headerSizeBuf, function() {
          var archiveFile, md5;
          archiveFile = fs.createReadStream(_this._archiveName);
          md5 = crypto.createHash('md5');
          archiveFile.pipe(md5);
          archiveFile.on('end', function() {
            var archiveSizeBuf;
            _this._checksum = md5.read();
            _this._archiveSize = _this._offset + _this._headerSize + _this.SIZELENGTH + 16 + _this.SIZELENGTH;
            if (_this._archiveSize > MAX_SAFE_INTEGER) {
              return typeof cb === "function" ? cb(new Error("archive size can not be larger than 9PB")) : void 0;
            }
            archiveSizeBuf = new Buffer(_this.SIZELENGTH);
            writeUINT64(archiveSizeBuf, _this._archiveSize);
            out.write(_this._checksum, function() {
              out.write(archiveSizeBuf, cb);
            });
          });
        });
      };
    })(this));
  };

  AsarArchive.prototype._crawlFilesystem = function(dir, pattern, cb) {
    var paths, walker;
    paths = [];
    walker = walkdir(dir);
    walker.on('path', function(p, stat) {
      paths.push({
        name: p,
        stat: stat
      });
    });
    walker.on('end', (function(_this) {
      return function() {
        var matchFn;
        if (pattern) {
          matchFn = minimatch.filter(pattern, {
            matchBase: true
          });
          paths = paths.filter(function(a) {
            return matchFn(path.sep + path.relative(dir, a.name));
          });
        }
        paths.sort(sortBy('name'));
        return typeof cb === "function" ? cb(null, paths) : void 0;
      };
    })(this));
    walker.on('error', cb);
  };

  AsarArchive.prototype.openSync = function(archiveName) {
    var err, fd;
    this.reset();
    this._archiveName = archiveName;
    try {
      this._archiveSize = fs.lstatSync(archiveName).size;
      fd = fs.openSync(archiveName, 'r');
      this._readHeader(fd);
    } catch (_error) {
      err = _error;
      throw err;
    }
    fs.closeSync(fd);
    if ((this._header.version != null) && this._header.version > this.VERSION) {
      throw new Error("Unsupported asar format version: " + this._header.version + " (max supported: " + this.VERSION + ")");
    }
    return true;
  };

  AsarArchive.prototype.write = function(archiveName, opts, cb) {
    var appendMode, out, start, writeArchive, writeFile;
    if (typeof opts === 'function') {
      cb = opts;
      opts = {};
    }
    appendMode = this._archiveName === archiveName;
    this._archiveName = archiveName;
    mkdirp.sync(path.dirname(archiveName));
    writeFile = (function(_this) {
      return function(filename, out, node, cb) {
        var gzip, realSize, src;
        realSize = 0;
        src = fs.createReadStream(filename);
        if (_this.opts.compress && node.size > _this.opts.minSizeToCompress) {
          gzip = zlib.createGzip();
          gzip.on('data', function(chunk) {
            realSize += chunk.length;
          });
          gzip.on('end', function() {
            node.offset = _this._offset;
            node.csize = realSize;
            _this._offset += realSize;
            cb();
          });
          src.pipe(gzip);
          gzip.pipe(out, {
            end: false
          });
        } else {
          src.on('data', function(chunk) {
            realSize += chunk.length;
          });
          src.on('end', function() {
            node.offset = _this._offset;
            _this._offset += realSize;
            cb();
          });
          src.pipe(out, {
            end: false
          });
        }
      };
    })(this);
    writeArchive = (function(_this) {
      return function(err, cb) {
        var file, i, q, _i, _len, _ref;
        if (err) {
          return typeof cb === "function" ? cb(err) : void 0;
        }
        q = queue(1);
        _ref = _this._files;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          file = _ref[i];
          q.defer(writeFile, file, out, _this._fileNodes[i]);
        }
        q.awaitAll(function(err) {
          if (err) {
            return typeof cb === "function" ? cb(err) : void 0;
          }
          return _this._writeFooter(out, function(err) {
            if (err) {
              return cb(err);
            }
            this._dirty = false;
            this._files = [];
            this._fileNodes = [];
            return cb();
          });
        });
      };
    })(this);
    start = appendMode ? this._offset : 0;
    if (appendMode) {
      out = fs.createWriteStream(archiveName, {
        flags: 'r+',
        start: start
      });
      writeArchive(null, cb);
    } else {
      out = fs.createWriteStream(archiveName);
      this._writeHeader(out, function(err) {
        return writeArchive(err, cb);
      });
    }
  };

  AsarArchive.prototype.verify = function(cb) {
    var archiveFile, endOfs, md5;
    endOfs = this._offset + this._headerSize + this.SIZELENGTH - 1;
    archiveFile = fs.createReadStream(this._archiveName, {
      start: 0,
      end: endOfs
    });
    md5 = crypto.createHash('md5');
    archiveFile.pipe(md5);
    archiveFile.on('end', (function(_this) {
      return function() {
        var actual, excpected;
        actual = md5.read().toString('hex');
        excpected = _this._checksum.toString('hex');
        cb(null, actual === excpected, {
          actual: actual,
          excpected: excpected
        });
      };
    })(this));
  };

  AsarArchive.prototype.getEntries = function(archiveRoot, pattern) {
    var files, fillFilesFromHeader, json, _ref;
    if (archiveRoot == null) {
      archiveRoot = '/';
    }
    if (pattern == null) {
      pattern = null;
    }
    if (archiveRoot.length > 1 && (_ref = archiveRoot[0], __indexOf.call('/\\'.split(''), _ref) >= 0)) {
      archiveRoot = archiveRoot.substr(1);
    }
    files = [];
    fillFilesFromHeader = function(p, json) {
      var f, fullPath;
      if ((json != null ? json.files : void 0) == null) {
        return;
      }
      for (f in json.files) {
        fullPath = path.join(p, f);
        files.push(fullPath);
        fillFilesFromHeader(fullPath, json.files[f]);
      }
    };
    if (archiveRoot === '/') {
      json = this._header;
    } else {
      json = this._searchNode(archiveRoot, false);
      if (json == null) {
        throw new Error("" + archiveRoot + " not found in " + this._archiveName);
      }
      if (json.size) {
        files.push(archiveRoot);
      }
      archiveRoot = "" + path.sep + archiveRoot;
    }
    fillFilesFromHeader(archiveRoot, json);
    if (pattern) {
      files = files.filter(minimatch.filter(pattern, {
        matchBase: true
      }));
    }
    return files;
  };

  AsarArchive.prototype.getMetadata = function(filename) {
    var node;
    node = this._searchNode(filename, false);
    return node;
  };

  AsarArchive.prototype.createReadStream = function(filename) {
    var emptyStream, end, gunzip, inStream, node, size, start;
    node = this._searchNode(filename, false);
    if (node.size > 0) {
      if (!this._legacyMode) {
        start = node.offset;
      } else {
        start = 8 + this._headerSize + parseInt(node.offset, 10);
      }
      size = node.csize || node.size;
      end = start + size - 1;
      inStream = fs.createReadStream(this._archiveName, {
        start: start,
        end: end
      });
      if (node.csize != null) {
        gunzip = zlib.createGunzip();
        inStream.pipe(gunzip);
        return gunzip;
      }
      return inStream;
    } else {
      emptyStream = stream.Readable();
      emptyStream.push(null);
      return emptyStream;
    }
  };

  AsarArchive.prototype.extract = function(dest, opts, cb) {
    var archiveRoot, destDir, destFilename, filename, filenames, linkTo, linkToRel, node, pattern, q, relativeTo, symlinksSupported, writeStreamToFile, _i, _len, _ref, _ref1;
    if (typeof opts === 'function') {
      cb = opts;
      opts = {};
    }
    if (typeof opts === 'string') {
      opts = {
        root: opts
      };
    }
    archiveRoot = opts.root || '/';
    pattern = opts.pattern;
    symlinksSupported = os.platform() !== 'win32';
    filenames = this.getEntries(archiveRoot, pattern);
    if (filenames.length === 1) {
      archiveRoot = path.dirname(archiveRoot);
    } else {
      mkdirp.sync(dest);
    }
    relativeTo = archiveRoot;
    if (_ref = relativeTo[0], __indexOf.call('/\\'.split(''), _ref) >= 0) {
      relativeTo = relativeTo.substr(1);
    }
    if (_ref1 = relativeTo.slice(-1), __indexOf.call('/\\'.split(''), _ref1) >= 0) {
      relativeTo = relativeTo.slice(0, -1);
    }
    writeStreamToFile = (function(_this) {
      return function(filename, destFilename, cb) {
        var inStream, out;
        inStream = _this.createReadStream(filename);
        out = fs.createWriteStream(destFilename);
        out.on('finish', cb);
        out.on('error', cb);
        inStream.pipe(out);
      };
    })(this);
    q = queue(1);
    for (_i = 0, _len = filenames.length; _i < _len; _i++) {
      filename = filenames[_i];
      destFilename = filename;
      if (relativeTo !== '.') {
        destFilename = destFilename.replace(relativeTo, '');
      }
      destFilename = path.join(dest, destFilename);
      if (this.opts.verbose) {
        console.log("-> " + destFilename);
      }
      node = this._searchNode(filename, false);
      if (node.files) {
        q.defer(mkdirp, destFilename);
      } else if (node.link) {
        if (symlinksSupported) {
          destDir = path.dirname(destFilename);
          q.defer(mkdirp, destDir);
          linkTo = path.join(destDir, relativeTo, node.link);
          linkToRel = path.relative(path.dirname(destFilename), linkTo);
          try {
            fs.unlinkSync(destFilename);
          } catch (_error) {}
          fs.symlinkSync(linkToRel, destFilename);
        } else {
          if (this.opts.verbose) {
            console.log("Warning: extracting symlinks on windows not yet supported. Skipping " + destFilename);
          }
        }
      } else {
        destDir = path.dirname(destFilename);
        q.defer(mkdirp, destDir);
        q.defer(writeStreamToFile, filename, destFilename);
      }
    }
    q.awaitAll(cb);
  };

  AsarArchive.prototype.addFile = function(filename, opts) {
    var node, p, relativeTo, stat;
    if (opts == null) {
      opts = {};
    }
    stat = opts.stat || fs.lstatSyc(filename);
    relativeTo = opts.relativeTo || path.dirname(filename);
    this._dirty = true;
    if (stat.size > MAX_SAFE_INTEGER) {
      throw new Error("" + p + ": file size can not be larger than 9PB");
    }
    p = path.relative(relativeTo, filename);
    node = this._searchNode(p);
    node.size = stat.size;
    if (node.size === 0) {
      return;
    }
    this._files.push(filename);
    this._fileNodes.push(node);
    if (process.platform === 'win32' && stat.mode & 0x40) {
      node.executable = true;
    }
  };

  AsarArchive.prototype.addSymlink = function(filename, opts) {
    var linkAbsolute, linkTo, node, p, pAbsDir, pDir, relativeTo;
    if (opts == null) {
      opts = {};
    }
    relativeTo = opts.relativeTo || path.dirname(filename);
    this._dirty = true;
    p = path.relative(relativeTo, filename);
    pDir = path.dirname(path.join(relativeTo, p));
    pAbsDir = path.resolve(pDir);
    linkAbsolute = fs.realpathSync(filename);
    linkTo = path.relative(pAbsDir, linkAbsolute);
    node = this._searchNode(p);
    node.link = linkTo;
  };

  AsarArchive.prototype.createDirectory = function(dirname) {
    var entry;
    this._dirty = true;
    entry = this._searchNode(dirname);
    if (entry.files == null) {
      entry.files = {};
    }
  };

  AsarArchive.prototype.addDirectory = function(dirname, opts, cb) {
    var relativeTo;
    if (opts == null) {
      opts = {};
    }
    if (cb == null) {
      cb = null;
    }
    this._dirty = true;
    if (typeof opts === 'function') {
      cb = opts;
      opts = {};
    }
    relativeTo = opts.relativeTo || dirname;
    this._crawlFilesystem(dirname, opts != null ? opts.pattern : void 0, (function(_this) {
      return function(err, files) {
        var file, _i, _len;
        for (_i = 0, _len = files.length; _i < _len; _i++) {
          file = files[_i];
          if (_this.opts.verbose) {
            console.log("+ " + path.sep + (path.relative(relativeTo, file.name)));
          }
          if (file.stat.isDirectory()) {
            _this.createDirectory(path.relative(relativeTo, file.name));
          } else if (file.stat.isFile()) {
            _this.addFile(file.name, {
              relativeTo: relativeTo,
              stat: file.stat
            });
          } else if (file.stat.isSymbolicLink()) {
            _this.addSymlink(file.name, {
              relativeTo: relativeTo
            });
          }
        }
        return typeof cb === "function" ? cb(null) : void 0;
      };
    })(this));
  };

  return AsarArchive;

})();
