// Generated by CoffeeScript 1.8.0
var AsarArchive, crawlFilesystem, crypto, fs, mkdirp, path, walkdir,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require('fs');

path = require('path');

crypto = require('crypto');

walkdir = require('walkdir');

mkdirp = require('mkdirp');

crawlFilesystem = function(dir, cb) {
  var paths, walker;
  paths = [];
  walker = walkdir(dir);
  walker.on('path', function(p, stat) {
    paths.push({
      name: p,
      stat: stat
    });
  });
  walker.on('end', function() {
    paths.sort(function(a, b) {
      if (a.name < b.name) {
        return -1;
      }
      if (a.name > b.name) {
        return 1;
      }
      return 0;
    });
    return cb(null, paths);
  });
  walker.on('error', cb);
};

module.exports = AsarArchive = (function() {
  function AsarArchive(opts) {
    this.opts = opts;
    this.reset();
    return;
  }

  AsarArchive.prototype.MAGIC = 'ASAR';

  AsarArchive.prototype.VERSION = 1;

  AsarArchive.prototype.reset = function() {
    this._header = {
      version: this.VERSION,
      files: {}
    };
    this._headerSize = 0;
    this._offset = 0;
    this._archiveSize = 0;
    this._files = [];
    this._archiveName = null;
    this._checksum = null;
    this._legacyMode = false;
  };

  AsarArchive.prototype._searchNode = function(p, create) {
    var dir, dirs, name, node, _i, _len, _ref;
    if (create == null) {
      create = true;
    }
    if (_ref = p[0], __indexOf.call('/\\'.split(''), _ref) >= 0) {
      p = p.substr(1);
    }
    name = path.basename(p);
    node = this._header;
    dirs = path.dirname(p).split(path.sep);
    for (_i = 0, _len = dirs.length; _i < _len; _i++) {
      dir = dirs[_i];
      if (node == null) {
        throw new Error("" + p + " not found.");
      }
      if (dir !== '.') {
        node = node.files[dir];
      }
    }
    if (create) {
      node.files[name] = {};
    }
    if (node == null) {
      throw new Error("" + p + " not found.");
    }
    node = node.files[name];
    return node;
  };

  AsarArchive.prototype._readHeader = function(fd) {
    var checksumSize, err, headerBuf, magicBuf, magicLen, size, sizeBuf, sizeBufSize;
    magicLen = this.MAGIC.length;
    magicBuf = new Buffer(magicLen);
    if (fs.readSync(fd, magicBuf, 0, magicLen, null) !== magicLen) {
      throw new Error('Unable to read from archive');
    }
    if (magicBuf.toString() !== this.MAGIC) {
      return this._readHeaderOld(fd);
    }
    sizeBufSize = 4;
    sizeBuf = new Buffer(sizeBufSize);
    if (fs.readSync(fd, sizeBuf, 0, sizeBufSize, null) !== sizeBufSize) {
      throw new Error('Unable to read header size');
    }
    size = sizeBuf.readUInt32LE(0);
    headerBuf = new Buffer(size);
    if (fs.readSync(fd, headerBuf, 0, size, null) !== size) {
      throw new Error('Unable to read header');
    }
    checksumSize = 16;
    this._checksum = new Buffer(checksumSize);
    if (fs.readSync(fd, this._checksum, 0, checksumSize, this._archiveSize - 16 - 4) !== checksumSize) {
      throw new Error('Unable to read checksum');
    }
    try {
      this._header = JSON.parse(headerBuf);
    } catch (_error) {
      err = _error;
      throw new Error('Unable to parse header');
    }
    this._headerSize = size;
  };

  AsarArchive.prototype._readHeaderOld = function(fd) {
    var actualSize, err, headerBuf, size, sizeBuf, sizeBufSize;
    this._legacyMode = true;
    sizeBufSize = 8;
    sizeBuf = new Buffer(sizeBufSize);
    if (fs.readSync(fd, sizeBuf, 0, sizeBufSize, 0) !== sizeBufSize) {
      throw new Error('Unable to read header size (assumed old format)');
    }
    size = sizeBuf.readUInt32LE(4);
    actualSize = size - 8;
    headerBuf = new Buffer(actualSize);
    if (fs.readSync(fd, headerBuf, 0, actualSize, 16) !== actualSize) {
      throw new Error('Unable to read header (assumed old format)');
    }
    try {
      this._header = JSON.parse(headerBuf);
    } catch (_error) {
      err = _error;
      throw new Error('Unable to parse header (assumed old format)');
    }
    this._headerSize = size;
  };

  AsarArchive.prototype._writeHeader = function(out, cb) {
    var headerStr, sizeBuf;
    headerStr = JSON.stringify(this._header);
    this._headerSize = headerStr.length;
    sizeBuf = new Buffer(4);
    sizeBuf.writeUInt32LE(this._headerSize, 0);
    out.write(this.MAGIC, function() {
      return out.write(sizeBuf, function() {
        return out.write(headerStr, cb);
      });
    });
  };

  AsarArchive.prototype._writeFooter = function(out, cb) {
    var archiveFile, md5;
    archiveFile = fs.createReadStream(this._archiveName);
    md5 = crypto.createHash('md5');
    archiveFile.pipe(md5);
    archiveFile.on('end', (function(_this) {
      return function() {
        var sizeBuf;
        _this._checksum = md5.read();
        _this._archiveSize = 8 + _this._headerSize + _this._offset + 16 + 4;
        if (_this._archiveSize > 4294967295) {
          return cb(new Error("archive size can not be larger than 4.2GB"));
        }
        sizeBuf = new Buffer(4);
        sizeBuf.writeUInt32LE(_this._archiveSize, 0);
        out.write(_this._checksum, function() {
          out.write(sizeBuf, cb);
        });
      };
    })(this));
  };

  AsarArchive.prototype.openSync = function(archiveName) {
    var err, fd;
    this.reset();
    this._archiveName = archiveName;
    try {
      this._archiveSize = fs.lstatSync(archiveName).size;
      fd = fs.openSync(archiveName, 'r');
      this._readHeader(fd);
    } catch (_error) {
      err = _error;
      throw err;
    }
    fs.closeSync(fd);
    if ((this._header.version != null) && this._header.version > this.VERSION) {
      throw new Error("Unsupported asar format version: " + this._header.version + " (max supported: " + this.VERSION + ")");
    }
    return true;
  };

  AsarArchive.prototype.write = function(archiveName, opts, cb) {
    var out, queue, writeFile;
    this._archiveName = archiveName;
    mkdirp.sync(path.dirname(archiveName));
    queue = require('queue-async');
    writeFile = function(filename, out, cb) {
      var src;
      src = fs.createReadStream(filename);
      src.on('end', cb);
      src.pipe(out, {
        end: false
      });
    };
    out = fs.createWriteStream(archiveName);
    this._writeHeader(out, (function(_this) {
      return function() {
        var file, q, _i, _len, _ref;
        q = queue(1);
        _ref = _this._files;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          file = _ref[_i];
          q.defer(writeFile, file, out);
          q.awaitAll(function(err) {
            if (err) {
              return cb(err);
            }
            return _this._writeFooter(out, cb);
          });
        }
      };
    })(this));
  };

  AsarArchive.prototype.getEntries = function(archiveRoot) {
    var files, fillFilesFromHeader, json, _ref;
    if (archiveRoot == null) {
      archiveRoot = '/';
    }
    if (archiveRoot.length > 1 && (_ref = archiveRoot[0], __indexOf.call('/\\'.split(''), _ref) >= 0)) {
      archiveRoot = archiveRoot.substr(1);
    }
    files = [];
    fillFilesFromHeader = function(p, json) {
      var f, fullPath;
      if ((json != null ? json.files : void 0) == null) {
        return;
      }
      for (f in json.files) {
        fullPath = path.join(p, f);
        files.push(fullPath);
        fillFilesFromHeader(fullPath, json.files[f]);
      }
    };
    if (archiveRoot === '/') {
      json = this._header;
    } else {
      json = this._searchNode(archiveRoot, false);
      if (json.size) {
        files.push(archiveRoot);
      }
      archiveRoot = "" + path.sep + archiveRoot;
    }
    fillFilesFromHeader(archiveRoot, json);
    return files;
  };

  AsarArchive.prototype.getMetadata = function(filename) {
    var node;
    node = this._searchNode(filename, false);
    return node;
  };

  AsarArchive.prototype.getFile = function(filename) {
    var buffer, fd, node;
    fd = fs.openSync(this._archiveName, 'r');
    node = this._searchNode(filename, false);
    buffer = new Buffer(node.size);
    fs.readSync(fd, buffer, 0, node.size, 8 + this._headerSize + parseInt(node.offset, 10));
    fs.closeSync(fd);
    return buffer;
  };

  AsarArchive.prototype.extractFileSync = function(filename, destFilename) {
    mkdirp.sync(path.dirname(destFilename));
    fs.writeFileSync(destFilename, this.getFile(filename));
    return true;
  };

  AsarArchive.prototype.extractSync = function(dest, archiveRoot) {
    var destFilename, filename, filenames, node, relativeTo, _i, _len, _ref, _ref1;
    if (archiveRoot == null) {
      archiveRoot = '/';
    }
    filenames = this.getEntries(archiveRoot);
    if (filenames.length === 1) {
      archiveRoot = path.dirname(archiveRoot);
    } else {
      mkdirp.sync(dest);
    }
    relativeTo = archiveRoot;
    if (_ref = relativeTo[0], __indexOf.call('/\\'.split(''), _ref) >= 0) {
      relativeTo = relativeTo.substr(1);
    }
    if (_ref1 = relativeTo.slice(-1), __indexOf.call('/\\'.split(''), _ref1) >= 0) {
      relativeTo = relativeTo.slice(0, -1);
    }
    for (_i = 0, _len = filenames.length; _i < _len; _i++) {
      filename = filenames[_i];
      destFilename = filename;
      if (relativeTo !== '.') {
        destFilename = destFilename.replace(relativeTo, '');
      }
      destFilename = path.join(dest, destFilename);
      if (this.opts.verbose) {
        console.log("" + filename + " -> " + destFilename);
      }
      node = this._searchNode(filename, false);
      if (node.files) {
        mkdirp.sync(destFilename);
      } else {
        this.extractFileSync(filename, destFilename);
      }
    }
    return true;
  };

  AsarArchive.prototype.addFile = function(filename, relativeTo, stat, content) {
    var node, p;
    if (stat == null) {
      stat = null;
    }
    if (content == null) {
      content = null;
    }
    if (stat == null) {
      stat = fs.lstatSyc(filename);
    }
    if (stat.size > 4294967295) {
      throw new Error("" + p + ": file size can not be larger than 4.2GB");
    }
    if (this._offset + stat.size > 4294967295) {
      throw new Error("" + p + ": archive size can not be larger than 4.2GB");
    }
    this._files.push(filename);
    p = path.relative(relativeTo, filename);
    node = this._searchNode(p);
    node.size = stat.size;
    node.offset = this._offset.toString();
    if (process.platform === 'win32' && stat.mode & 0x40) {
      node.executable = true;
    }
    this._offset += stat.size;
  };

  AsarArchive.prototype.createDirectory = function(dirname) {
    var entry;
    entry = this._searchNode(dirname);
    entry.files = {};
  };

  AsarArchive.prototype.addDirectory = function(dirname, relativeTo, cb) {
    crawlFilesystem(dirname, (function(_this) {
      return function(err, files) {
        var file, _i, _len;
        for (_i = 0, _len = files.length; _i < _len; _i++) {
          file = files[_i];
          if (_this.opts.verbose) {
            console.log("+ " + path.sep + (path.relative(relativeTo, file.name)));
          }
          if (file.stat.isDirectory()) {
            _this.createDirectory(path.relative(relativeTo, file.name));
          } else if (file.stat.isFile()) {
            _this.addFile(file.name, relativeTo, file.stat);
          }
        }
        return cb(null);
      };
    })(this));
  };

  return AsarArchive;

})();
