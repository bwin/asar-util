// Generated by CoffeeScript 1.8.0
var AsarArchiveBase, AsarArchiveFs, UINT64, crypto, fs, mkdirp, path, queue, readUINT64, sortBy, stream, walkdir, writeUINT64, zlib,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

fs = require('fs');

path = require('path');

crypto = require('crypto');

zlib = require('zlib');

stream = require('stream');

walkdir = require('walkdir');

mkdirp = require('mkdirp');

queue = require('queue-async');

UINT64 = require('cuint').UINT64;

AsarArchiveBase = require('./archive-base');

writeUINT64 = function(buf, val, ofs) {
  var uintval;
  if (ofs == null) {
    ofs = 0;
  }
  uintval = UINT64(val);
  buf.writeUInt16LE(uintval._a00, ofs + 0);
  buf.writeUInt16LE(uintval._a16, ofs + 2);
  buf.writeUInt16LE(uintval._a32, ofs + 4);
  buf.writeUInt16LE(uintval._a48, ofs + 6);
  return buf;
};

readUINT64 = function(buf, ofs) {
  var hi, lo, val;
  if (ofs == null) {
    ofs = 0;
  }
  lo = buf.readUInt32LE(ofs + 0);
  hi = buf.readUInt32LE(ofs + 4);
  val = UINT64(lo, hi).toNumber();
  return val;
};

sortBy = function(prop) {
  return function(a, b) {
    if (a[prop] < b[prop]) {
      return -1;
    }
    if (a[prop] > b[prop]) {
      return 1;
    }
    return 0;
  };
};

module.exports = AsarArchiveFs = (function(_super) {
  __extends(AsarArchiveFs, _super);

  function AsarArchiveFs() {
    this.extractSymlink = __bind(this.extractSymlink, this);
    this.extractFile = __bind(this.extractFile, this);
    return AsarArchiveFs.__super__.constructor.apply(this, arguments);
  }

  AsarArchiveFs.prototype._crawlFilesystem = function(dir, pattern, cb) {
    var paths, walker;
    paths = [];
    walker = walkdir(dir);
    walker.on('path', function(p, stat) {
      paths.push({
        name: p,
        stat: stat
      });
    });
    walker.on('end', (function(_this) {
      return function() {
        var matchFn;
        if (pattern) {
          matchFn = minimatch.filter(pattern, {
            matchBase: true
          });
          paths = paths.filter(function(a) {
            return matchFn(path.sep + path.relative(dir, a.name));
          });
        }
        paths.sort(sortBy('name'));
        return typeof cb === "function" ? cb(null, paths) : void 0;
      };
    })(this));
    walker.on('error', cb);
  };

  AsarArchiveFs.prototype._readHeader = function(fd) {
    var checksumOfs, checksumSize, err, headerBuf, headerOfs, headerSize, headerSizeBuf, headerSizeOfs, magicBuf, magicLen;
    magicLen = this.MAGIC.length;
    magicBuf = new Buffer(magicLen);
    if (fs.readSync(fd, magicBuf, 0, magicLen, null) !== magicLen) {
      throw new Error("Unable to open archive: " + this._archiveName);
    }
    if (magicBuf.toString() !== this.MAGIC) {
      return this._readHeaderOld(fd);
    }
    headerSizeOfs = this._archiveSize - (this.SIZELENGTH + 16 + this.SIZELENGTH);
    headerSizeBuf = new Buffer(this.SIZELENGTH);
    if (fs.readSync(fd, headerSizeBuf, 0, this.SIZELENGTH, headerSizeOfs) !== this.SIZELENGTH) {
      throw new Error("Unable to read header size: " + this._archiveName);
    }
    headerSize = readUINT64(headerSizeBuf);
    headerOfs = this._archiveSize - headerSize - (this.SIZELENGTH + 16 + this.SIZELENGTH);
    headerBuf = new Buffer(headerSize);
    if (fs.readSync(fd, headerBuf, 0, headerSize, headerOfs) !== headerSize) {
      throw new Error("Unable to read header: " + this._archiveName);
    }
    this._offset = headerOfs;
    checksumSize = 16;
    checksumOfs = this._archiveSize - 16 - this.SIZELENGTH;
    this._checksum = new Buffer(checksumSize);
    if (fs.readSync(fd, this._checksum, 0, checksumSize, checksumOfs) !== checksumSize) {
      throw new Error("Unable to read checksum: " + this._archiveName);
    }
    try {
      this._header = JSON.parse(headerBuf);
    } catch (_error) {
      err = _error;
      throw new Error("Unable to parse header: " + this._archiveName);
    }
    this._headerSize = headerSize;
  };

  AsarArchiveFs.prototype._readHeaderOld = function(fd) {
    var actualSize, err, headerBuf, headerStr, size, sizeBuf, sizeBufSize;
    this._legacyMode = true;
    sizeBufSize = 8;
    sizeBuf = new Buffer(sizeBufSize);
    if (fs.readSync(fd, sizeBuf, 0, sizeBufSize, 0) !== sizeBufSize) {
      throw new Error('Unable to read header size (assumed old format)');
    }
    size = sizeBuf.readUInt32LE(4);
    actualSize = size - 8;
    headerBuf = new Buffer(actualSize);
    if (fs.readSync(fd, headerBuf, 0, actualSize, 16) !== actualSize) {
      throw new Error('Unable to read header (assumed old format)');
    }
    try {
      headerStr = headerBuf.toString().replace(/\0+$/g, '');
      this._header = JSON.parse(headerStr);
    } catch (_error) {
      err = _error;
      throw new Error('Unable to parse header (assumed old format)');
    }
    this._headerSize = size;
  };

  AsarArchiveFs.prototype._writeHeader = function(out, cb) {
    out.write(this.MAGIC, cb);
  };

  AsarArchiveFs.prototype._writeFooter = function(out, cb) {
    var headerSizeBuf, headerStr;
    if (this.opts.prettyToc) {
      headerStr = JSON.stringify(this._header, null, '  ').replace(/\n/g, '\r\n');
      headerStr = "\r\n" + headerStr + "\r\n";
    } else {
      headerStr = JSON.stringify(this._header);
    }
    this._headerSize = headerStr.length;
    headerSizeBuf = new Buffer(this.SIZELENGTH);
    writeUINT64(headerSizeBuf, this._headerSize);
    out.write(headerStr, (function(_this) {
      return function() {
        out.write(headerSizeBuf, function() {
          var archiveFile, md5;
          archiveFile = fs.createReadStream(_this._archiveName);
          md5 = crypto.createHash('md5');
          archiveFile.pipe(md5);
          archiveFile.on('end', function() {
            var archiveSizeBuf;
            _this._checksum = md5.read();
            _this._archiveSize = _this._offset + _this._headerSize + _this.SIZELENGTH + 16 + _this.SIZELENGTH;
            if (_this._archiveSize > _this.MAX_SAFE_INTEGER) {
              return typeof cb === "function" ? cb(new Error("archive size can not be larger than 9PB")) : void 0;
            }
            archiveSizeBuf = new Buffer(_this.SIZELENGTH);
            writeUINT64(archiveSizeBuf, _this._archiveSize);
            out.write(_this._checksum, function() {
              out.write(archiveSizeBuf, cb);
            });
          });
        });
      };
    })(this));
  };

  AsarArchiveFs.prototype._calcArchiveChecksum = function(cb) {
    var archiveFile, endOfs, md5;
    endOfs = this._offset + this._headerSize + this.SIZELENGTH - 1;
    archiveFile = fs.createReadStream(this._archiveName, {
      start: 0,
      end: endOfs
    });
    md5 = crypto.createHash('md5');
    archiveFile.pipe(md5);
    archiveFile.on('error', cb);
    return archiveFile.on('end', function() {
      return cb(null, md5.read().toString('hex'));
    });
  };

  AsarArchiveFs.prototype.createReadStream = function(filename) {
    var emptyStream, end, gunzip, inStream, node, size, start;
    node = this._searchNode(filename, false);
    if (node.size > 0) {
      if (!this._legacyMode) {
        start = node.offset;
      } else {
        start = 8 + this._headerSize + parseInt(node.offset, 10);
      }
      size = node.csize || node.size;
      end = start + size - 1;
      inStream = fs.createReadStream(this._archiveName, {
        start: start,
        end: end
      });
      if (node.csize != null) {
        gunzip = zlib.createGunzip();
        inStream.pipe(gunzip);
        return gunzip;
      }
      return inStream;
    } else {
      emptyStream = stream.Readable();
      emptyStream.push(null);
      return emptyStream;
    }
  };

  AsarArchiveFs.prototype.openSync = function(archiveName) {
    var err, fd;
    this.reset();
    this._archiveName = archiveName;
    try {
      this._archiveSize = fs.lstatSync(archiveName).size;
      fd = fs.openSync(archiveName, 'r');
      this._readHeader(fd);
    } catch (_error) {
      err = _error;
      throw err;
    }
    fs.closeSync(fd);
    if ((this._header.version != null) && this._header.version > this.VERSION) {
      throw new Error("Unsupported asar format version: " + this._header.version + " (max supported: " + this.VERSION + ")");
    }
    return true;
  };

  AsarArchiveFs.prototype.write = function(archiveName, opts, cb) {
    var appendMode, out, start, writeArchive, writeFile;
    if (typeof opts === 'function') {
      cb = opts;
      opts = {};
    }
    appendMode = this._archiveName === archiveName;
    this._archiveName = archiveName;
    mkdirp.sync(path.dirname(archiveName));
    writeFile = (function(_this) {
      return function(filename, out, internalFilename, node, cb) {
        var gzip, realSize, src;
        if (_this.opts.verbose) {
          console.log("+ " + path.sep + internalFilename);
        }
        realSize = 0;
        src = fs.createReadStream(filename);
        if (_this.opts.compress && node.size > _this.opts.minSizeToCompress) {
          gzip = zlib.createGzip();
          gzip.on('data', function(chunk) {
            realSize += chunk.length;
          });
          gzip.on('end', function() {
            node.offset = _this._offset;
            node.csize = realSize;
            _this._offset += realSize;
            cb();
          });
          src.pipe(gzip);
          gzip.pipe(out, {
            end: false
          });
        } else {
          src.on('data', function(chunk) {
            realSize += chunk.length;
          });
          src.on('end', function() {
            node.offset = _this._offset;
            _this._offset += realSize;
            cb();
          });
          src.pipe(out, {
            end: false
          });
        }
      };
    })(this);
    writeArchive = (function(_this) {
      return function(err, cb) {
        var file, i, q, _i, _len, _ref;
        if (err) {
          return typeof cb === "function" ? cb(err) : void 0;
        }
        q = queue(1);
        _ref = _this._files;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          file = _ref[i];
          q.defer(writeFile, file, out, _this._filesInternalName[i], _this._fileNodes[i]);
        }
        q.awaitAll(function(err) {
          if (err) {
            return typeof cb === "function" ? cb(err) : void 0;
          }
          return _this._writeFooter(out, function(err) {
            if (err) {
              return cb(err);
            }
            this._dirty = false;
            this._files = [];
            this._filesInternalName = [];
            this._fileNodes = [];
            return cb();
          });
        });
      };
    })(this);
    start = appendMode ? this._offset : 0;
    if (appendMode) {
      out = fs.createWriteStream(archiveName, {
        flags: 'r+',
        start: start
      });
      writeArchive(null, cb);
    } else {
      out = fs.createWriteStream(archiveName);
      this._writeHeader(out, function(err) {
        return writeArchive(err, cb);
      });
    }
  };

  AsarArchiveFs.prototype.extractFile = function(filename, destFilename, cb) {
    var inStream, out;
    if (this.opts.verbose) {
      console.log("-> " + destFilename);
    }
    inStream = this.createReadStream(filename);
    out = fs.createWriteStream(destFilename);
    out.on('finish', cb);
    out.on('error', cb);
    inStream.pipe(out);
  };

  AsarArchiveFs.prototype.extractSymlink = function(filename, destFilename, cb) {
    var destDir, linkTo, linkToRel;
    destDir = path.dirname(destFilename);
    mkdirp.sync(destDir);
    linkTo = path.join(destDir, relativeTo, node.link);
    linkToRel = path.relative(path.dirname(destFilename), linkTo);
    try {
      fs.unlinkSync(destFilename);
    } catch (_error) {}
    fs.symlinkSync(linkToRel, destFilename);
    return cb(null);
  };

  return AsarArchiveFs;

})(AsarArchiveBase);
