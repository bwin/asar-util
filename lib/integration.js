// Generated by CoffeeScript 1.8.0
var asar, asarStatsToFsStats, cachedArchives, child_process, copyFileOut, createNotFoundError, dbg, fakeTime, fs, getOrLoadArchive, gid, maxCompatibility, nextInode, originalLstatSync, overrideAPI, overrideAPISync, path, reportArchiveAsDirectory, splitPath, temp, uid;

fs = require('fs');

child_process = require('child_process');

path = require('path');

temp = require('temp');

asar = require('./asar');

reportArchiveAsDirectory = true;

maxCompatibility = false;

dbg = false;

overrideAPISync = function(module, name, arg) {
  var old;
  if (arg == null) {
    arg = 0;
  }
  old = module[name];
  return module[name] = function() {
    var asarPath, filePath, isAsar, newPath, p, _ref;
    if (dbg) {
      console.log("*** overrideAPISync " + name, arguments);
    }
    p = arguments[arg];
    _ref = splitPath(p), isAsar = _ref[0], asarPath = _ref[1], filePath = _ref[2];
    if (!isAsar) {
      return old.apply(this, arguments);
    }
    newPath = copyFileOut(asarPath, filePath);
    if (!newPath) {
      throw new Error('tempfileerror');
    }
    arguments[arg] = newPath;
    return old.apply(this, arguments);
  };
};

overrideAPI = function(module, name, arg) {
  var old;
  if (arg == null) {
    arg = 0;
  }
  old = module[name];
  return module[name] = function() {
    var asarPath, callback, filePath, isAsar, newPath, p, _ref;
    if (dbg) {
      console.log("*** overrideAPI " + name, arguments);
    }
    p = arguments[arg];
    _ref = splitPath(p), isAsar = _ref[0], asarPath = _ref[1], filePath = _ref[2];
    if (!isAsar) {
      return old.apply(this, arguments);
    }
    callback = arguments[arguments.length - 1];
    if (typeof callback !== 'function') {
      return overrideAPISync(module, name, arg);
    }
    newPath = copyFileOut(asarPath, filePath);
    if (!newPath) {
      throw new Error('tempfileerror');
    }
    arguments[arg] = newPath;
    return old.apply(this, arguments);
  };
};

copyFileOut = function(asarPath, filePath) {
  var archive, content, metadata, tempFile;
  archive = getOrLoadArchive(asarPath);
  if (!archive) {
    throw new Error("Invalid package " + asarPath);
  }
  metadata = archive.getMetadata(filePath);
  if (!metadata) {
    throw new Error("File not found in package " + asarPath + ":" + filePath);
  }
  tempFile = temp.openSync("asar-" + (path.basename(filePath)) + "-");
  content = archive.getFile(filePath);
  if (!content) {
    throw new Error("Could not read from package " + asarPath + ":" + filePath);
  }
  fs.writeSync(tempFile.fd, content, 0, content.length);
  fs.closeSync(tempFile.fd);
  if (dbg) {
    console.log("*** TMP file ***", asarPath, filePath);
  }
  return tempFile.path;
};

createNotFoundError = function(asarPath, filePath) {
  var error;
  error = new Error("ENOENT, " + filePath + " not found in " + asarPath);
  error.code = "ENOENT";
  error.errno = -2;
  return error;
};

cachedArchives = {};

getOrLoadArchive = function(p) {
  var archive, err;
  archive = cachedArchives[p];
  if (archive != null) {
    return archive;
  }
  try {
    archive = asar.loadArchive(p);
  } catch (_error) {
    err = _error;
    console.log("ERR", err);
    return false;
  }
  if (!archive) {
    return false;
  }
  cachedArchives[p] = archive;
  return archive;
};

originalLstatSync = fs.lstatSync;

splitPath = function(p) {
  var filePath, match, matchPath, matchStat, matches, _i, _len;
  if (typeof p !== 'string') {
    return [false];
  }
  matches = p.match(/.*?\.asar/g);
  if (!matches) {
    return [false];
  }
  matchPath = '';
  for (_i = 0, _len = matches.length; _i < _len; _i++) {
    match = matches[_i];
    matchPath = [matchPath, match].filter(function(x) {
      return x;
    }).join('/');
    matchStat = {
      isFile: function() {
        return true;
      }
    };
    filePath = p.replace(matchPath, '');
    if (filePath === '' && !reportArchiveAsDirectory) {
      return [false];
    }
    if (matchStat.isFile()) {
      return [true, matchPath, filePath];
    }
  }
  return [false];
};

nextInode = 0;

uid = process.getuid != null ? process.getuid() : 0;

gid = process.getgid != null ? process.getgid() : 0;

fakeTime = new Date();

asarStatsToFsStats = function(metadata) {
  return {
    dev: 1,
    ino: ++nextInode,
    mode: 33188,
    nlink: 1,
    uid: uid,
    gid: gid,
    rdev: 0,
    atime: fakeTime,
    birthtime: fakeTime,
    mtime: fakeTime,
    ctime: fakeTime,
    size: metadata.size || 0,
    isFile: function() {
      return metadata.size != null;
    },
    isDirectory: function() {
      return metadata.files != null;
    },
    isSymbolicLink: function() {
      return metadata.link != null;
    },
    isBlockDevice: function() {
      return false;
    },
    isCharacterDevice: function() {
      return false;
    },
    isFIFO: function() {
      return false;
    },
    isSocket: function() {
      return false;
    }
  };
};

module.exports = {
  takeOver: function(hostObj) {
    var origFs;
    if (hostObj == null) {
      hostObj = require('fs');
    }
    origFs = {
      openSync: hostObj.openSync,
      closeSync: hostObj.closeSync,
      readSync: hostObj.readSync,
      existsSync: hostObj.existsSync,
      statSync: hostObj.statSync,
      lstatSync: hostObj.lstatSync,
      fstatSync: hostObj.fstatSync
    };
    if (maxCompatibility) {
      overrideAPISync(fs, 'openSync');
    } else {
      hostObj.openSync = function(p, flags, mode) {
        var archive, asarPath, filePath, isAsar, metadata, _ref;
        if (dbg) {
          console.log("* openSync", p);
        }
        _ref = splitPath(p), isAsar = _ref[0], asarPath = _ref[1], filePath = _ref[2];
        if (!isAsar) {
          return origFs.openSync(p, flags, mode);
        }
        archive = getOrLoadArchive(asarPath);
        if (!archive) {
          throw new Error("Invalid package " + asarPath);
        }
        metadata = archive.getMetadata(filePath);
        if (metadata) {
          if (dbg) {
            console.log("--- open File found", filePath);
          }
        } else {
          if (dbg) {
            console.log("--- open File NOT found", filePath);
          }
        }
        if (!metadata) {
          throw new Error("File not found in package " + asarPath + ":" + filePath);
        }
        return {
          asarPath: asarPath,
          filePath: filePath
        };
      };
    }
    overrideAPI(fs, 'open');
    overrideAPI(child_process, 'execFile');
    overrideAPISync(process, 'dlopen', 1);
    overrideAPISync(require('module')._extensions, '.node', 1);
    overrideAPISync(child_process, 'fork');
    hostObj.statSync = function(path) {
      var archive, asarPath, filePath, isAsar, metadata, stat, _ref;
      _ref = splitPath(path), isAsar = _ref[0], asarPath = _ref[1], filePath = _ref[2];
      if (dbg) {
        console.log("* statSync", path, [isAsar, asarPath, filePath]);
      }
      if (!isAsar) {
        return origFs.statSync(path);
      }
      archive = getOrLoadArchive(asarPath);
      if (!archive) {
        throw new Error("Invalid package " + asarPath);
      }
      metadata = archive.getMetadata(filePath);
      if (metadata) {
        if (dbg) {
          console.log("--- stat File found", filePath);
        }
      } else {
        if (dbg) {
          console.log("--- stat File NOT found", filePath);
        }
      }
      if (!metadata) {
        throw new Error("File not found in package " + asarPath + ":" + filePath);
      }
      stat = asarStatsToFsStats(metadata);
      return stat;
    };
    hostObj.lstatSync = function(path) {
      var archive, asarPath, filePath, isAsar, metadata, stat, _ref;
      _ref = splitPath(path), isAsar = _ref[0], asarPath = _ref[1], filePath = _ref[2];
      if (dbg) {
        console.log("* LstatSync", path, [isAsar, asarPath, filePath]);
      }
      if (!isAsar) {
        return origFs.lstatSync(path);
      }
      archive = getOrLoadArchive(asarPath);
      if (!archive) {
        throw new Error("Invalid package " + asarPath);
      }
      if (filePath) {
        metadata = archive.getMetadata(filePath);
      } else {
        metadata = {
          files: 1
        };
      }
      if (metadata) {
        if (dbg) {
          console.log("--- lstat File found", filePath);
        }
      } else {
        if (dbg) {
          console.log("--- lstat File NOT found", filePath);
        }
      }
      if (!metadata) {
        throw new Error("File not found in package " + asarPath + ":" + filePath);
      }
      stat = asarStatsToFsStats(metadata);
      return stat;
    };
    hostObj.fstatSync = function(fd) {
      var archive, asarPath, filePath, metadata, stat;
      if (fd.asarPath == null) {
        return origFs.fstatSync(fd);
      }
      asarPath = fd.asarPath, filePath = fd.filePath;
      archive = getOrLoadArchive(asarPath);
      if (!archive) {
        throw new Error("Invalid package " + asarPath);
      }
      metadata = archive.getMetadata(filePath);
      if (!metadata) {
        throw new Error("File not found in package " + asarPath + ":" + filePath);
      }
      stat = asarStatsToFsStats(metadata);
      return stat;
    };
    hostObj.closeSync = function(fd) {
      if (dbg) {
        console.log("* closeSync", fd);
      }
      if (fd.asarPath == null) {
        return origFs.closeSync(fd);
      }
      return true;
    };
    hostObj.readSync = function(fd, buffer, offset, length, position) {
      var archive, asarPath, data, fake, filePath;
      if (dbg) {
        console.log("** readSync fd=" + fd + " offset=" + offset + " length=" + length + " position=" + position);
      }
      if (fd.asarPath == null) {
        return origFs.readSync(fd, buffer, offset, length, position);
      }
      asarPath = fd.asarPath, filePath = fd.filePath;
      if (dbg) {
        console.log("** readSync it is asar", asarPath, filePath);
      }
      archive = getOrLoadArchive(asarPath);
      if (!archive) {
        throw new Error("Invalid package " + asarPath);
      }
      data = archive.getFile(filePath).slice(offset, length);
      if (!data) {
        return 0;
      }
      if (typeof data === 'string') {
        buffer.write(data);
      } else {
        data.copy(buffer);
      }
      return data.length;
      if (offset) {
        return 0;
      }
      fake = '{}';
      buffer.write(fake);
      return fake.length;
    };
    return hostObj.existsSync = function(path) {
      var archive, asarPath, err, filePath, isAsar, source, _ref;
      if (dbg) {
        console.log("** existsSync", path);
      }
      _ref = splitPath(path), isAsar = _ref[0], asarPath = _ref[1], filePath = _ref[2];
      if (!isAsar) {
        return origFs.existsSync(path);
      }
      try {
        archive = getOrLoadArchive(asarPath);
      } catch (_error) {
        err = _error;
        if (!archive) {
          throw new Error("Invalid package " + asarPath);
        }
      }
      try {
        source = archive.getFile(filePath);
      } catch (_error) {
        err = _error;
        return false;
      }
      return true;
    };
  }
};
