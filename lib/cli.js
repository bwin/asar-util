// Generated by CoffeeScript 1.8.0
var Progress, appendDir, archive, argv, asar, bar, compatibilityMode, debug, doCompress, doOverwrite, done, entries, entry, err, examples, filesAdded, fs, generalError, help, input, inputPath, inputStat, line, logFilenames, logFilenamesThrottled, metadata, minimist, niceSize, nodeFilesize, onProgress, onProgressThrottled, os, output, path, pattern, pkg, prettyPrint, quiet, root, showExamples, showHelp, showList, showListSize, showVersion, throttle, truncatePath, usageError, useColors, verbose, verify, _i, _len;

fs = require('fs');

os = require('os');

path = require('path');

minimist = require('minimist');

Progress = require('progress');

nodeFilesize = require('filesize');

asar = require('./asar');

pkg = require('../package');

argv = minimist(process.argv.slice(2), {
  string: '_ i in o out a add r root'.split(' '),
  boolean: 'h help v version examples w overwrite z compress P pretty l list s size verify info c colors C compat Q verbose debug q quiet'.split(' '),
  "default": {
    root: '/'
  }
});

help = function() {
  return console.log("" + pkg.name + " [input] [output] [options]\nParameter:\ninput                 path to archive or directory\noutput                path to archive or directory\nor if you prefer, you can set these with:\n-i, --in <path>       specify input (can be archive or directory)\n-o, --out <path>      specify output (can be archive or directory)\nOptions:\n-h, --help            show help and exit\n-v, --version         show version and exit\n    --examples        show example usage and exit\n    --verify          verify archive integrity and exit\n    --info            output archive info and exit\n-l, --list            list archive entries and exit\n-s, --size            also list size\n-a, --add <path>      path to directory to add to archive\n-r, --root <path>     set root path in archive\n-p, --pattern <glob>  set a filter pattern\n-w, --overwrite       overwrite files\n-z, --compress        gzip file contents\n-P, --pretty          write pretty printed json TOC\n-c, --colors          use terminal colors for output\n-C, --compat          also read legacy asar format\n-Q, --verbose         more feedback\n    --debug           a lot feedback\n-q, --quiet           no feedback");
};

examples = function() {
  return console.log("" + pkg.name + "\nExamples:\ncreate archive from dir:            asar-util dir archive\nsame with named parameters:         asar-util -i dir -o archive\nextract archive to dir:             asar-util archive dir\nextract root from archive to dir:   asar-util archive dir -r root\nextract d/file from archive to dir: asar-util archive dir -r d/file\nverify archive:                     asar-util archive --verify\nlist archive entries:               asar-util archive -l\nlist archive entries for root:      asar-util archive -l -r root\nlist entries for root with pattern: asar-util archive -l -r root -p pattern\nlist archive entries with size:     asar-util archive -ls");
};

showHelp = argv.help || argv.h;

showVersion = argv.version || argv.v;

showExamples = argv.examples;

input = argv.i || argv["in"] || argv._[0];

output = argv.o || argv.out || argv._[1];

appendDir = argv.a || argv.add;

root = argv.r || argv.root;

pattern = argv.p || argv.pattern;

doOverwrite = argv.w || argv.overwrite;

doCompress = argv.z || argv.compress;

prettyPrint = argv.P || argv.pretty;

showList = argv.l || argv.list;

showListSize = argv.s || argv.size;

verify = argv.verify;

useColors = argv.c || argv.colors;

compatibilityMode = argv.C || argv.compat;

verbose = argv.Q || argv.verbose;

debug = argv.debug;

quiet = argv.q || argv.quiet;

if (useColors) {
  require('terminal-colors');
  String.prototype.__defineGetter__('error', function() {
    return this.red;
  });
  String.prototype.__defineGetter__('warning', function() {
    return this.yellow;
  });
  String.prototype.__defineGetter__('info', function() {
    return this.cyan;
  });
  String.prototype.__defineGetter__('success', function() {
    return this.green;
  });
} else {
  String.prototype.__defineGetter__('error', function() {
    return '' + this;
  });
  String.prototype.__defineGetter__('warning', function() {
    return '' + this;
  });
  String.prototype.__defineGetter__('info', function() {
    return '' + this;
  });
  String.prototype.__defineGetter__('success', function() {
    return '' + this;
  });
}

usageError = function(msg) {
  console.error(("usage error: " + msg + os.EOL).error);
  help();
  return process.exit(-1);
};

generalError = function(msg) {
  if (!quiet) {
    console.error(("" + msg + os.EOL).error);
  }
  return process.exit(1);
};

done = function(err) {
  if (err) {
    generalError(err.message);
  }
  if (typeof onProgress === "function") {
    onProgress(bar.total, bar.total, 'done.');
  }
  if (!quiet) {
    console.log("ok.".success);
  }
  return process.exit(0);
};

truncatePath = function(filename, maxLenght) {
  var last, len, result, results, truncated;
  if (maxLenght == null) {
    maxLenght = 0;
  }
  if (maxLenght === 0) {
    return filename;
  }
  truncated = false;
  result = filename;
  results = result.split(/[\\\/]+/g);
  while (results.length > 1 && result.length + 3 > maxLenght) {
    truncated = true;
    results = result.split(/[\\\/]+/g);
    last = results.pop();
    results.pop();
    results.push(last);
    result = results.join(path.sep);
  }
  if (result.length + 3 > maxLenght) {
    len = result.length + 3;
    result = '...' + result.substr(len - maxLenght);
    return result;
  }
  if (truncated) {
    results = result.split(/[\\\/]+/g);
    last = results.pop();
    results.push('...');
    results.push(last);
    result = results.join(path.sep);
  }
  return result;
};

throttle = function(fn, threshhold, scope) {
  var deferTimer, last;
  threshhold || (threshhold = 250);
  last = void 0;
  deferTimer = void 0;
  return function() {
    var args, context, now;
    context = scope || this;
    now = +(new Date);
    args = arguments;
    if (last && now < last + threshhold) {
      clearTimeout(deferTimer);
      deferTimer = setTimeout(function() {
        last = now;
        fn.apply(context, args);
      }, threshhold);
    } else {
      last = now;
      fn.apply(context, args);
    }
  };
};

niceSize = function(size) {
  var result;
  result = nodeFilesize(size, {
    output: 'object'
  });
  return "" + (result.value.toFixed(2)) + result.suffix;
};

if (!quiet) {
  bar = new Progress(':bar :percent :mbWritten/:mbTotal :filename', {
    total: 0,
    width: 20,
    incomplete: '▒',
    complete: '█'
  });
  onProgress = function(total, progress, filename) {
    bar.total = total;
    return bar.tick(0, {
      filename: truncatePath(filename, 30),
      mbWritten: niceSize(bar.curr),
      mbTotal: niceSize(bar.total)
    });
  };
  onProgressThrottled = throttle(onProgress, 150);
  asar.opts.onProgress = function(total, progress, filename) {
    bar.curr += progress;
    return onProgressThrottled(total, progress, filename);
  };
}

if (verbose) {
  if (quiet) {
    usageError('Y U mix --verbose and --quiet ?! U crazy');
  }
  asar.opts.verbose = true;
  filesAdded = [];
  logFilenames = function() {
    var filename, _i, _len;
    process.stdout.clearLine();
    process.stdout.cursorTo(0);
    for (_i = 0, _len = filesAdded.length; _i < _len; _i++) {
      filename = filesAdded[_i];
      console.log("" + filename);
    }
    filesAdded = [];
    if (bar.curr > 0) {
      return bar.tick(0);
    }
  };
  logFilenamesThrottled = throttle(logFilenames, 150);
  asar.opts.onFileBegin = function(filename) {
    filesAdded.push(filename);
    return logFilenamesThrottled();
  };
}

if (debug) {
  asar.opts.debug = true;
  if (quiet) {
    usageError('Y U mix --debug and --quiet ?! U crazy');
  }
}

if (doCompress) {
  asar.opts.compress = true;
}

if (prettyPrint) {
  asar.opts.prettyToc = true;
}

inputPath = [];

inputPath.push('.');

if (root === '/' || root === '\\') {
  inputPath.push(input);
} else {
  inputPath.push("" + input + ":");
  inputPath.push(root);
}

if (pattern) {
  inputPath.push(pattern);
}

inputPath = path.join.apply(null, inputPath).info;

if (showHelp) {
  help();
} else if (showExamples) {
  examples();
} else if (showVersion) {
  console.log("v" + pkg.version);
} else if (input) {
  if (verify) {
    if (output) {
      usageError('output and --verify not allowed together');
    }
    try {
      archive = asar.loadArchive(input);
    } catch (_error) {
      err = _error;
      generalError(err.message);
    }
    if (!quiet) {
      console.log("verifying " + input.info);
    }
    archive.verify(function(err, ok) {
      if (ok) {
        return done();
      } else {
        return generalError('wrong checksum');
      }
    });
  } else if (appendDir) {
    if (output) {
      usageError('output and --add not allowed together');
    }
    if (!quiet) {
      console.log("adding " + (appendDir + (pattern || '')).info + " to " + input.info);
    }
    archive = asar.loadArchive(input);
    archive.addDirectory(appendDir, {
      pattern: pattern
    }, function(err) {
      if (err) {
        return done(err);
      }
      return archive.write(input, done);
    });
  } else if (output) {
    try {
      inputStat = fs.lstatSync(input);
    } catch (_error) {
      err = _error;
      generalError("input not found: " + input);
    }
    if (inputStat.isDirectory()) {
      if (root !== '/') {
        usageError('using --root is not allowed for packing');
      }
      if (!quiet) {
        console.log("packing " + inputPath + " to " + output.info);
      }
      asar.createArchive(input, output, pattern, done);
    } else {
      if (!quiet) {
        console.log("extracting " + inputPath + " to " + output.info);
      }
      asar.extractArchive(input, output, {
        root: root,
        pattern: pattern
      }, done);
    }
  } else {
    if (showListSize) {
      try {
        archive = asar.loadArchive(input);
        entries = archive.getEntries(root, pattern);
      } catch (_error) {
        err = _error;
        generalError(err.message);
      }
      for (_i = 0, _len = entries.length; _i < _len; _i++) {
        entry = entries[_i];
        metadata = archive.getMetadata(entry);
        line = entry;
        if (metadata.files != null) {
          line += path.sep;
        }
        if (metadata.size != null) {
          line += "\t" + metadata.size;
        }
        console.log(line);
      }
    } else {
      try {
        entries = asar.getEntries(input, root, pattern);
      } catch (_error) {
        err = _error;
        generalError(err.message);
      }
      console.log(entries.join(os.EOL));
    }
  }
} else {
  usageError('no input specified');
}
